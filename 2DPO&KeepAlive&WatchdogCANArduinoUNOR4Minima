// DPO Byte	Value
// 0	0x01 → PWM_OUTPUT_CMD
// 1	Channel (0 or 1)
// 2	Duty (0–100)
// 3	Reserved (0)
// 4	Frequency LSB
// 5	Frequency MSB
// 6	0
// 7	0

// KeepALive Byte	Field	Description
// 0	Message Type	0x02 for KeepAlive
// 1	Node ID	0x01 = UNO R4 Minima, 0x02 = Nano (example)
// 2	Status Flags	Bitfield for error/warning/status (0x00 = OK)
// 3	Sequence Counter	Incremented every KeepAlive frame (0–255)
// 4	Uptime LSB	Milliseconds/seconds LSB (mod 256, e.g., uptime % 256)
// 5	Uptime MSB	Milliseconds/seconds MSB
// 6	Reserved	0x00 for future use
// 7	Checksum	Simple XOR of bytes 0–6

#include <Arduino_CAN.h>

#define PWM_CMD_ID        0x2D0      // DPOrxCANAddress1
#define PWM_CMD_TYPE      0x01
#define KEEPALIVE_ID      0x2C6      // KeepAlive frame from Nano
#define KEEPALIVE_INTERVAL_MS 100     // Send every 100ms
#define NANO_TIMEOUT_MS   300         // Nano watchdog timeout

static uint8_t keepaliveSeq = 0;
unsigned long lastKeepAliveSent = 0;
unsigned long lastNanoKeepAlive = 0;

void setup() {
  Serial.begin(115200);
  while (!Serial);

  Serial.println("UNO R4 CAN PWM Controller");
  Serial.println("Type: pwm <channel> <freqHz> <duty%>");
  Serial.println("Example: pwm 0 1000 50");

  if (!CAN.begin(CanBitRate::BR_1000k)) {
    Serial.println("CAN init failed");
    while (1);
  }

  Serial.println("CAN ready");

  // Set PWM safe state initially
  enterSafeState();
}

/************ LOOP ************/
void loop() {
  unsigned long now = millis();

  // ---- Send KeepAlive ----
  if (now - lastKeepAliveSent >= KEEPALIVE_INTERVAL_MS) {
    sendKeepAlive();
    lastKeepAliveSent = now;
  }

  // ---- Check for Nano KeepAlive ----
  if (CAN.available()) {
    CanMsg msg = CAN.read();

    // PWM command
    if (msg.id == PWM_CMD_ID && msg.data_length == 8) {
      handlePWMCan(msg);
      delay(5); // Small delay to avoid CAN overflow
    }

    // Nano KeepAlive
    if (msg.id == KEEPALIVE_ID && msg.data_length == 8) {
      lastNanoKeepAlive = now;
      // Optional: Could decode status flags or sequence if desired
    }
  }

  // ---- Nano Watchdog ----
  if (now - lastNanoKeepAlive > NANO_TIMEOUT_MS) {
    Serial.println("ERROR: Nano not responding → entering SAFE STATE");
    enterSafeState();
    lastNanoKeepAlive = now; // prevent repeated prints
  }

  // ---- Serial command parser ----
  if (Serial.available()) {
    String line = Serial.readStringUntil('\n');
    line.trim();

    if (line.startsWith("pwm")) {
      handlePWMCommand(line);
    } else {
      Serial.println("Unknown command");
    }
  }
}

/************ SAFE STATE ************/
void enterSafeState() {
  uint8_t data[8] = {0};
  data[0] = PWM_CMD_TYPE;
  data[1] = 0; // channel 0
  data[2] = 0; // duty 0
  data[3] = 0;
  data[4] = 0; // freq LSB
  data[5] = 0; // freq MSB
  data[6] = 0;
  data[7] = 0;
  CanMsg msg0(CanStandardId(PWM_CMD_ID), 8, data);
  CAN.write(msg0);

  data[1] = 1; // channel 1
  CanMsg msg1(CanStandardId(PWM_CMD_ID), 8, data);
  CAN.write(msg1);

  Serial.println("PWM outputs set to SAFE STATE");
}

/************ SEND PWM CAN ************/
void sendPWMCan(uint8_t channel, uint16_t freq, uint8_t duty) {
  uint8_t data[8] = {0};
  data[0] = PWM_CMD_TYPE;
  data[1] = channel;
  data[2] = duty;
  data[3] = 0;
  data[4] = freq & 0xFF;
  data[5] = (freq >> 8) & 0xFF;
  data[6] = 0;
  data[7] = 0;

  CanMsg msg(CanStandardId(PWM_CMD_ID), 8, data);
  int rc = CAN.write(msg);
  if (rc < 0) Serial.print("CAN send failed: "), Serial.println(rc);
  else {
    Serial.print("Sent PWM → ch=");
    Serial.print(channel);
    Serial.print(" freq=");
    Serial.print(freq);
    Serial.print("Hz duty=");
    Serial.print(duty);
    Serial.println("%");
  }
}

/************ SEND KEEPALIVE ************/
void sendKeepAlive() {
  uint8_t data[8] = {0};
  data[0] = 0x02;               // KeepAlive message type
  data[1] = 0x01;               // Node ID (UNO)
  data[2] = 0x00;               // Status flags OK
  data[3] = keepaliveSeq++;     // Sequence
  uint16_t uptime = millis() / 1000; // seconds
  data[4] = uptime & 0xFF;      // LSB
  data[5] = (uptime >> 8) & 0xFF;// MSB
  data[6] = 0x00;               // Reserved
  data[7] = data[0]^data[1]^data[2]^data[3]^data[4]^data[5]^data[6]; // Checksum

  CanMsg msg(CanStandardId(KEEPALIVE_ID), 8, data);
  CAN.write(msg);
}

/************ HANDLE PWM CAN ************/
void handlePWMCan(CanMsg msg) {
  if (msg.data_length != 8) return;
  uint8_t channel = msg.data[1];
  uint8_t duty    = msg.data[2];
  uint16_t freq   = (msg.data[5] << 8) | msg.data[4];
  sendPWMCan(channel, freq, duty);

  // Small delay to prevent CAN overflow
  delay(5);
}

/************ SERIAL COMMAND PARSER ************/
void handlePWMCommand(String cmd) {
  int channel, freq, duty;
  int parsed = sscanf(cmd.c_str(), "pwm %d %d %d", &channel, &freq, &duty);
  if (parsed != 3) {
    Serial.println("Format error. Use: pwm <ch> <freq> <duty>");
    return;
  }
  if (channel < 0 || channel > 1 || freq <= 0 || freq > 20000 || duty < 0 || duty > 100) {
    Serial.println("Invalid parameters");
    return;
  }
  sendPWMCan(channel, freq, duty);

  // Small delay to prevent CAN buffer overflow
  delay(5);
}
