#include <Arduino_CAN.h>
#include <Arduino.h>
#include <pwm.h>

#define PWM_CMD_ID        0x2D0      // DPOrxCANAddress1
#define PWM_CMD_TYPE      0x01
#define KEEPALIVE_ID      0x2C6      // KeepAlive frame from Nano
#define DIGITAL_OUTPUT_CAN_ID 0x2D2  // CAN ID for digital outputs from Nano
#define KEEPALIVE_INTERVAL_MS 100
#define NANO_TIMEOUT_MS   300

static uint8_t keepaliveSeq = 0;
unsigned long lastKeepAliveSent = 0;
unsigned long lastNanoKeepAlive = 0;

// PWM output pins
PwmOut pwmA(6);
PwmOut pwmB(9);
PwmOut pwmC(10);
PwmOut pwmD(11);

// Current values
uint32_t freq[4] = {1000, 1000, 1000, 1000}; // default 1 kHz
uint8_t duty[4] = {128, 128, 128, 128};      // default 50% (0-255)

// Map indices to PWM objects and pins
PwmOut* pwm[4] = {&pwmA, &pwmB, &pwmC, &pwmD};
uint8_t digitalPins[4] = {6, 9, 10, 11};

// Apply frequency and duty dynamically using PWMout
void applyDigitalPWM(uint8_t ch, uint32_t newFreq, uint8_t newDuty)
{
    if (ch >= 4) return;

    // Save values
    freq[ch] = newFreq;
    duty[ch] = (newDuty > 255) ? 255 : newDuty;

    // Compute period in microseconds
    uint32_t period_us = 1000000UL / freq[ch];

    // Set frequency using PwmOut
    pwm[ch]->begin(period_us, 0);  // duty handled by analogWrite

    // Set duty via 12-bit analogWrite
    analogWrite(digitalPins[ch], (uint16_t)(duty[ch] * 4095UL / 100UL)); // both values 12-bit resolution
}

void setup() {
  Serial.begin(115200);
  while (!Serial);

  Serial.println("UNO R4 CAN PWM Controller + Digital Output Receiver");
  Serial.println("Type: pwm <channel> <freqHz> <duty%>");
  Serial.println("Digital outputs controlled via CAN ID 0x2D2");

  if (!CAN.begin(CanBitRate::BR_1000k)) {
    Serial.println("CAN init failed");
    while (1);
  }

  Serial.println("CAN ready");

  // Set PWM safe state initially
  enterSafeState();

  analogWriteResolution(12);  // 12-bit PWM

// Initialize all 4 PWM outputs to 1 kHz, 50% duty
for (uint8_t i = 0; i < 4; i++) {
    applyDigitalPWM(i, freq[i], duty[i]); // freq = 1000 Hz, duty = 128/255 ≈ 50%
}

    Serial.println("Output PWM initialized.");
  }

// loop
void loop() {
  unsigned long now = millis();

  // ---- Send KeepAlive ----
  if (now - lastKeepAliveSent >= KEEPALIVE_INTERVAL_MS) {
    sendKeepAlive();
    lastKeepAliveSent = now;
  }

  // ---- Check for incoming CAN messages ----
  if (CAN.available()) {
    CanMsg msg = CAN.read();

    // PWM command
    if (msg.id == PWM_CMD_ID && msg.data_length == 8) {
      handlePWMCan(msg);
      delay(5);
    }

    // Nano KeepAlive
    if (msg.id == KEEPALIVE_ID && msg.data_length == 8) {
      lastNanoKeepAlive = now;
    }

    // Digital output command from Nano
    if (msg.id == DIGITAL_OUTPUT_CAN_ID && msg.data_length == 8) {
      handleDigitalOutputCan(msg);
      delay(5);
    }
  }

  // Nano Watchdog
  if (now - lastNanoKeepAlive > NANO_TIMEOUT_MS) {
    Serial.println("ERROR: Nano not responding → entering SAFE STATE");
    enterSafeState();
    lastNanoKeepAlive = now; // prevent repeated prints
  }

  // Serial command parser
  if (Serial.available()) {
    String line = Serial.readStringUntil('\n');
    line.trim();

    if (line.startsWith("pwm")) {
      handlePWMCommand(line);
    } else {
      Serial.println("Unknown command");
    }
  }
}

// Safe State
void enterSafeState() {
  uint8_t data[8] = {0};
  data[0] = PWM_CMD_TYPE;
  data[1] = 0; // channel 0
  data[2] = 0; // duty 0
  data[3] = 0;
  data[4] = 0; // freq LSB
  data[5] = 0; // freq MSB
  data[6] = 0;
  data[7] = 0;
  CanMsg msg0(CanStandardId(PWM_CMD_ID), 8, data);
  CAN.write(msg0);

  data[1] = 1; // channel 1
  CanMsg msg1(CanStandardId(PWM_CMD_ID), 8, data);
  CAN.write(msg1);

// Set all PWM pins to 0% duty for safe state
for (uint8_t i = 0; i < 4; i++) {
    applyDigitalPWM(i, 1000, 0); // freq = 1 kHz (or keep previous), duty = 0
}

  Serial.println("PWM and digital outputs set to SAFE STATE");
}

// Send PWM CAN
void sendPWMCan(uint8_t channel, uint16_t freq, uint8_t duty) {
  uint8_t data[8] = {0};
  data[0] = PWM_CMD_TYPE;
  data[1] = channel;
  data[2] = duty;
  data[3] = 0;
  data[4] = freq & 0xFF;
  data[5] = (freq >> 8) & 0xFF;
  data[6] = 0;
  data[7] = 0;

  CanMsg msg(CanStandardId(PWM_CMD_ID), 8, data);
  int rc = CAN.write(msg);
  if (rc < 0) Serial.print("CAN send failed: "), Serial.println(rc);
  else {
    Serial.print("Sent PWM → ch=");
    Serial.print(channel);
    Serial.print(" freq=");
    Serial.print(freq);
    Serial.print("Hz duty=");
    Serial.print(duty);
    Serial.println("%");
  }
}

// SendKeepAlive
void sendKeepAlive() {
  uint8_t data[8] = {0};
  data[0] = 0x02;               // KeepAlive message type
  data[1] = 0x01;               // Node ID (UNO)
  data[2] = 0x00;               // Status flags OK
  data[3] = keepaliveSeq++;     // Sequence
  uint16_t uptime = millis() / 1000; // seconds
  data[4] = uptime & 0xFF;      // LSB
  data[5] = (uptime >> 8) & 0xFF;// MSB
  data[6] = 0x00;               // Reserved
  data[7] = data[0]^data[1]^data[2]^data[3]^data[4]^data[5]^data[6]; // Checksum

  CanMsg msg(CanStandardId(KEEPALIVE_ID), 8, data);
  CAN.write(msg);
}

// Hanle PWM CAN
void handlePWMCan(CanMsg msg) {
  if (msg.data_length != 8) return;
  uint8_t channel = msg.data[1];
  uint8_t duty    = msg.data[2];
  uint16_t freq   = (msg.data[5] << 8) | msg.data[4];
  sendPWMCan(channel, freq, duty);

  delay(5);
}

// HANDLE DIGITAL OUTPUT CAN
void handleDigitalOutputCan(CanMsg msg) {
  if (msg.data_length != 8) return;
  uint8_t channel = msg.data[1];
  uint8_t duty    = msg.data[2];
  uint16_t freq   = (msg.data[5] << 8) | msg.data[4];

  if (channel >= 4) return; // only 0–3 valid

  applyDigitalPWM(channel, freq, duty); // control of output pins

  // Optional: print info
  Serial.print("Digital Output → pin=");
  Serial.print(digitalPins[channel]);
  Serial.print(" freq=");
  Serial.print(freq);
  Serial.print("Hz duty=");
  Serial.print(duty);
  Serial.println("%");
}

// Serial Command Parser
void handlePWMCommand(String cmd) {
  int channel, freq, duty;
  int parsed = sscanf(cmd.c_str(), "pwm %d %d %d", &channel, &freq, &duty);
  if (parsed != 3) {
    Serial.println("Format error. Use: pwm <ch> <freq> <duty>");
    return;
  }
  if (channel < 0 || channel > 1 || freq <= 0 || freq > 20000 || duty < 0 || duty > 100) {
    Serial.println("Invalid parameters");
    return;
  }
  sendPWMCan(channel, freq, duty);

  delay(5);
}
